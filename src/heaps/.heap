use std::{
    fmt::{Debug, Display},
    vec,
};

pub type Unit<T, P> = (P, Option<T>);
#[derive(Debug)]
pub enum HeapType {
    Min,
    Max,
}

pub struct Heap<T: Debug, P: Ord> {
    arr: Vec<Unit<T, P>>,
    heap_type: HeapType,
}

impl<T: Debug, P: Ord + Display> Debug for Heap<T, P> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut paint = "".to_string();
        let mut i: f32 = 0.0;
        while self.arr.get(i as usize).is_some() {
            let log_i = (i + 2.0).log2();
            paint.push_str(&format!(".{}.", self.arr[i as usize].0,));
            if log_i == log_i.floor() {
                paint.push_str("\n");
            }
            i += 1.0;
        }
        write!(f, "{}", paint)
    }
}

impl<T: Debug, P: Ord> Into<Vec<Unit<T, P>>> for Heap<T, P> {
    fn into(self) -> Vec<Unit<T, P>> {
        self.arr
    }
}
impl<T: Debug + Copy, P: Ord + Copy> Heap<T, P> {
    pub fn new(heap_type: HeapType) -> Self {
        Self {
            arr: vec![],
            heap_type,
        }
    }

    pub fn size(&self) -> usize {
        self.arr.len()
    }
    pub fn is_empty(&self) -> bool {
        self.arr.len() == 0
    }

    pub fn insert(&mut self, unit: Unit<T, P>) {
        self.arr.push(unit);
        self.swim(self.size() - 1);
    }

    pub fn insert_from_arr(&mut self, datas: &mut [P]) {
        self.arr.append(datas.to_vec());
        for i in 0..datas.len() {
            self.insert((datas[i], None));
        }
    }

    pub fn extract(&mut self) -> Option<Unit<T, P>> {
        self.delete_at(0)
    }
    pub fn delete_at(&mut self, at: usize) -> Option<Unit<T, P>> {
        if self.arr.get(at).is_none() {
            None
        } else if self.size() == 1 {
            Some(self.arr.pop().unwrap())
        } else {
            let elem = self.arr[at].clone();
            self.arr[at] = self.arr.pop().unwrap();
            self.sink(at);
            Some(elem)
        }
    }

    pub fn cmp(&self, v1: P, v2: P) -> bool {
        match self.heap_type {
            HeapType::Min => v1 < v2,
            HeapType::Max => v1 > v2,
        }
    }
    pub fn right(&self, index: usize) -> usize {
        index * 2 + 2
    }
    pub fn left(&self, index: usize) -> usize {
        index * 2 + 1
    }
    fn sink(&mut self, index: usize) -> bool {
        if self.left(index) > self.size() - 1 {
            false
        } else if self.arr.get(index * 2 + 1).is_some() && self.arr.get(index * 2 + 2).is_none() {
            let select_index = index * 2 + 1;
            if !self.cmp(self.arr[index].0, self.arr[select_index].0) {
                self.arr.swap(index, select_index);
                self.sink(select_index);
            }
            true
        } else {
            let left_key = self.arr[index * 2 + 1].0;
            let right_key = self.arr[index * 2 + 2].0;
            let select_index = if match self.heap_type {
                HeapType::Min => left_key < right_key,
                HeapType::Max => left_key > right_key,
            } {
                index * 2 + 1
            } else {
                index * 2 + 2
            };
            if !self.cmp(self.arr[index].0, self.arr[select_index].0) {
                self.arr.swap(index, select_index);
                self.sink(select_index);
            }
            true
        }
    }

    fn swim(&mut self, mut index: usize) -> bool {
        while index != 0 {
            let parent_idx = index / 2;
            let child = self.arr[index].0;
            let parent = self.arr[parent_idx].0;
            if self.cmp(child, parent) {
                self.arr.swap(index, parent_idx);
            }

            index = parent_idx;
        }
        true
    }

    pub fn depth(&self) -> usize {
        if self.is_empty() {
            0
        } else {
            (self.size() as f32).log2().floor() as usize + 1
        }
    }
}

#[test]
fn from_vec_test() {
    let mut he: Heap<i32, i32> = Heap::new(HeapType::Max);
    he.insert_from_arr(&[1, 2, 3, 4, 5, 6, 7]);
    println!("{:?}", he);
}

#[test]
fn _test() {
    let mut heap: Heap<i32, usize> = Heap::new(HeapType::Max);
    let vec_: Vec<(i32, i32)> = vec![(1, 2), (3, 4)];
    heap.insert_from_arr(&[1, 2, 3, 4, 5, 6, 7]);
    println!("--------");
    println!("{:?}", heap);
    heap.extract();
    // println!("--------");
    println!("{:?}", heap);
    // heap.extract();
    // println!("--------");
    // println!("{:?}", heap);
    // heap.extract();
    // println!("--------");
    // println!("{:?}", heap);
    // heap.extract();
    // println!("--------");
    // println!("{:?}", heap);
    // heap.extract();
    // println!("--------");
    // println!("{:?}", heap);
}
