---
time: 2022/8/31
---
# 二叉堆(Binary Heap)

二叉堆是 `完全二叉树` 或者是 `近似完全二叉树`

## 几个定义

- **完全二叉树**: 若设二叉树的深度为*n*除第*n*层外，其它各层 (1～*n*−1) 的结点数都达到最大个数，第*n*层所有的结点都连续集中在最左边，这就是完全二叉树。
- **满二叉树**: 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为*n*，且结点总数是2*n*−1 ，则它就是满二叉树。

- **优先队列**: 堆(heap)又被称为**优先队列(priority queue)**。尽管名为优先队列，但堆并不是队列。回忆一下，在队列中，我们可以进行的限定操作是dequeue和enqueue。dequeue是按照进入队列的先后顺序来取出元素。而在堆中，我们不是按照元素进入队列的先后顺序取出元素的，而是按照元素的优先级取出元素。

- 堆的一个经典的实现是**完全二叉树(complete binary tree)**。这样实现的堆成为**二叉堆(binary heap)**。由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，**一般将二叉堆就简称为堆。**

## 二叉堆特性

 1. 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值
 2. 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆

## 实现方法

1. 添加节点: `insert()`
   - `swim()`
2. 提取最值: `extract()`
   - `sink()`
3. 删除索引节点`delete_at()`
   - `sink()`
4. 获得最值: `peek()`

5. 堆是否为空: `is_empty()`

6. 堆节点个数 `size()`

7. 建堆 `build_from_vec()`
   - `sink()`

## 关键函数——上浮和下沉: `swim()` and  `sink()`

- 当我们要加入一个元素的时候，我们需要维持堆的特性，因此在每次把元素插入到数列最后之后，对该索引进行一次上浮操作(swim)通过不断比较父节点，如果是最大堆，子节点大于父节点交换，递归继续向上，如果是最小堆，子节点小于父节点则递归向上

- 当要弹出最顶端的元素的时候，我们可以复制顶部元素后把原来顶部的空位以最后一个元素代替，然后对顶端做下沉操作(sink)，在孩子存在的情况下，如果父节点小于两者中较大的元素，则交换。并且递归继续下沉。

关于如何把数组转化成堆堆问题

1. 遍历数组堆所有元素，然后依次进行insert操作 O(nlog(n))
2. ～ 有没有更好的呢？  O(n)
